import { Scanner } from './scanner';
import { Identifier, IdentifierStack } from './identifier';
import { Token, Tokens } from '../constant/token';
import { Errors, ThrowError, skip } from '../constant/errors';
import { PathMap, ErrorOutout } from '../types/interfaces';
import { readFileSync } from 'fs';

class Parser {
  private getToken: () => Token | null;
  private source: string[];
  private tokens: Token[];
  private pointer: number;
  private endImport: boolean = false;
  private nowLevel: number = 0;
  private idStack: IdentifierStack = new IdentifierStack();
  private includePath: PathMap;
  private importedModule: string[] = [];

  public nowToken: Token | null = null;
  public errorCount: number;
  public errorMessages: ErrorOutout;
  public result: string = '';

  constructor(includePath: { [key: string]: string }) {
    this.includePath = includePath;
  }

  // 初始化 Parser
  public init(scanner: Scanner): void {
    this.getToken = scanner.nextToken.bind(scanner);
    this.source = scanner.getSource();
    this.tokens = [];
    this.result = '';
    this.pointer = -1;
    this.errorMessages = { textify: '', errors: [] };
    this.errorCount = 0;
  }

  // 取得下一個 Token
  public nextToken(): void {
    this.nowToken = this.getToken();
  }

  // 提供外部取得原始碼的方法
  public getSource(): string[] {
    return [...this.source];
  }

  // 載入所有 Token
  private loadAllToken(): void {
    while(true) {
      this.nextToken();
      if (!this.nowToken) break;
      this.tokens.push(this.nowToken);
    }
  }

  // 將指向某 Token 的指標移動至下一個
  private movePointerToNext(): void {
    this.pointer++;
    this.nowToken = this.tokens[this.pointer];
  }

  // 將指向某 Token 的指標移動至前一個
  private revert(): void {
    this.pointer--;
    this.nowToken = this.tokens[this.pointer];
  }

  // 檢查現在的 Token 是否為某些
  private nowTokenIs(...tokens: Tokens[]): boolean {
    if (!this.nowToken?.token) return false;
    return tokens.includes(this.nowToken?.token);
  }

  // 宣告變數
  private declareVariable(idToken: Token) {
    // 從識別字堆疊中尋找此區域是否有相同變數名稱
    const tmp = this.idStack.getId(idToken.value, this.nowLevel);
    // 如果沒有，宣告成功
    if (!tmp) return this.idStack.push(new Identifier(idToken, this.nowLevel));

    // 如果有，擲出變數重複宣告錯誤
    ThrowError(this, Errors.RedeclareIdentifier, idToken);
    skip(this, Tokens.Assignment);
  }

  // 當離開一程式碼區域時做的清理動作
  private leaveBlock() {
    // 將識別字堆疊中此區域宣告的的識別字全部移除
    while (this.idStack.top() && this.idStack.top()?.level == this.nowLevel)
      this.idStack.pop();

    // 往外一層
    this.nowLevel--;
  }


  // 建碼函式
  private buildCode(code: string) {
    this.result += code;
  }

  // 開始轉換
  public parse(): void {
    // 如果是空檔案就直接結束
    if (!this.source.filter(v => v.replace(/ +/, '')).length) return;

    // 載入所有 Token
    this.loadAllToken();
    // 設定目前原始碼巢狀深度
    this.nowLevel = 1;
    // 載入核心模組
    this.buildCode(
      readFileSync(
        this.includePath['core'], 'utf-8'
      )
    );

    // 如果 Scanner 不小心掃到尾巴，這裡把他拿掉
    // @ts-ignore
    if (this.tokens[this.tokens.length-1].value === -1 || this.tokens[this.tokens.length-1].value === '-1') this.tokens.pop();

    // 指標開始移動
    this.movePointerToNext();

    // 解析引入模組區
    while(this.nowToken && !this.endImport) {
      this.Include();
    }
    // 解析一般區
    while(this.nowToken) {
      this.Statement();
    }

    // 程式結尾處的建碼
    this.buildCode("_end();\n");
    this.buildCode("/* This code is generated by Official HiZollo Script compiler */");
  }

  /** 以下全為規則 **/

  private Include(): void {
    if (this.nowTokenIs(Tokens.Import)) {
      this.movePointerToNext();
      if (this.nowTokenIs(Tokens.String)) {
        // @ts-ignore
        const moduleName = this.nowToken.value.slice(1, -1)

        // 不能手動引入核心模組
        if (moduleName === 'core') {
          ThrowError(this, Errors.CantImportCoreModule, this.nowToken);
          this.revert();
          skip(this, Tokens.Include);
          return;
        }

        // importedModule 存有已經被引入的模組名稱，防止使用者重複引入
        if (this.importedModule.includes(moduleName)) {
          ThrowError(this, Errors.AlreadyImported, this.nowToken);
          this.revert();
          skip(this, Tokens.Include);
          return;
        }

        const pathOrCode = this.includePath[moduleName];
        // 找不到模組
        if (!pathOrCode) {
          ThrowError(this, Errors.ModuleNotFound, this.nowToken);
          this.revert();
          skip(this, Tokens.Include);
          return;
        }

        // 解析究竟是模組路徑或模組原始碼
        const moduleCode = pathOrCode.startsWith('code:')
          ? pathOrCode.slice(5)
          : readFileSync(pathOrCode, 'utf-8');

        // 建碼
        this.buildCode(moduleCode.trim() + '\n');
        // 將模組放入以引入的模組清單
        this.importedModule.push(moduleName);
        this.movePointerToNext();
        return;
      }
      this.revert();
      ThrowError(this, Errors.MissingModuleName, this.nowToken);
      skip(this, Tokens.Include);
      return;
    }

    // 結束引入階段（引入敘述只能放在程式開頭）
    this.endImport = true;

    // 程式正式開始的建碼
    this.buildCode("_start();");
  }

  private Statement(): void {
    if (!this.nowToken) return;

    if (this.nowTokenIs(Tokens.Import)) {
      ThrowError(this, Errors.LateImport, this.nowToken);
      skip(this, Tokens.Statement);
      return;
    }

    if (this.nowTokenIs(Tokens.Identifier)) {
      const nowId = this.nowToken;
      this.movePointerToNext();

      if (this.nowTokenIs(Tokens.Declare)) {
        this.declareVariable(nowId);
        this.buildCode(`let ${makeId(nowId.value)}=`);
        this.movePointerToNext();
        this.Declaration();
        this.buildCode(";")
        return;
      }

      if (this.nowTokenIs(Tokens.Assign)) {
        this.revert();
        this.Identifier();
        this.movePointerToNext();
        this.Assignment();
        this.buildCode(";");
        return;
      }

      if (this.nowTokenIs(Tokens.LeftBracket)) {
        this.buildCode(`${nowId.value}(`);
        this.movePointerToNext();
        this.Function();
        this.buildCode(";");
        return;
      }

      this.revert();
      ThrowError(this, Errors.MissingDeclareOrAssignOperator, this.nowToken);
      skip(this, Tokens.Statement);
      return;
    }

    if (this.nowTokenIs(Tokens.LeftCurlyBracket)) {
      this.movePointerToNext();
      this.If();
      return;
    }

    if (this.nowTokenIs(Tokens.LeftSquareBracket)) {
      this.movePointerToNext();
      this.For();
      return;
    }

    if (this.nowTokenIs(Tokens.Write)) {
      this.movePointerToNext();
      this.Print();
      this.buildCode(";");
      return;
    }

    ThrowError(this, Errors.UnknownStatement, this.nowToken);
  }

  private Declaration(): void {
    this.Number();
  }

  private Assignment(): void {
    this.buildCode("=");
    this.Expression();
  }

  private Function(): void {
    if (this.nowTokenIs(Tokens.RightBracket)) {
      this.buildCode(")");
      this.movePointerToNext();
      return;
    }

    this.ParameterList();

    if (this.nowTokenIs(Tokens.RightBracket)) {
      this.buildCode(")");
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingRightBracket, this.nowToken);
      skip(this, Tokens.Function);
    }
  }

  private ParameterList(): void {
    this.Parameter();
    while(this.nowTokenIs(Tokens.Comma)) {
      this.buildCode(',');
      this.movePointerToNext();
      this.Parameter();
    }
  }

  private Parameter(): void {
    if (this.nowTokenIs(Tokens.String)) {
      this.String();
      return;
    }

    this.Expression();
    return;
  }

  private If(): void {
    this.IfHead();

    if (this.nowTokenIs(Tokens.LeftBracket)) {
      this.buildCode("{");
      this.nowLevel++;
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingLeftBracket, this.nowToken);
      skip(this, Tokens.If);
    }

    while(this.nowTokenIs(Tokens.Identifier, Tokens.LeftCurlyBracket, Tokens.LeftSquareBracket, Tokens.Write)) {
      this.Statement();
    }

    if (this.nowTokenIs(Tokens.RightBracket)) {
      this.buildCode('}');
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingRightBracket, this.nowToken);
      skip(this, Tokens.If);
    }

    this.leaveBlock();

    if (this.nowTokenIs(Tokens.Divide)) {
      this.movePointerToNext();
      if (this.nowTokenIs(Tokens.LeftCurlyBracket)) {
        this.buildCode('else ');
        this.movePointerToNext();
        this.If();
        return;
      }
      this.Else();
    }


  }

  private IfHead(): void {
    this.buildCode("if(");
    this.Condition();

    if (this.nowTokenIs(Tokens.RightCurlyBracket)) {
      this.buildCode(')');
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingRightCurlyBracket, this.nowToken);
      skip(this, Tokens.IfHead);
    }
  }

  private Condition(): void {
    this.Expression();

    if (this.nowTokenIs(Tokens.LessThan, Tokens.GreaterThan, Tokens.LessOrEqual, Tokens.GreaterOrEqual, Tokens.Equal, Tokens.Inequal)) {
      this.buildCode(this.nowToken!.value);
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.InvalidComparation, this.nowToken);
      skip(this, Tokens.Condition);
      return;
    }

    this.Expression();
  }

  private Else(): void {
    if (this.nowTokenIs(Tokens.LeftBracket)) {
      this.nowLevel++;
      this.buildCode('else{');
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingLeftBracket, this.nowToken);
      skip(this, Tokens.Else);
    }

    while(this.nowTokenIs(Tokens.Identifier, Tokens.LeftCurlyBracket, Tokens.LeftSquareBracket, Tokens.Write)) {
      this.Statement();
    }

    if (this.nowTokenIs(Tokens.RightBracket)) {
      this.buildCode('}');
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingRightBracket, this.nowToken);
    }

    this.leaveBlock();

  }

  private For(): void {
    this.nowLevel++;
    this.ForHead();

    if (this.nowTokenIs(Tokens.LeftBracket)) {
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingLeftBracket, this.nowToken);
      skip(this, Tokens.Statement);
    }

    this.buildCode("{");

    while(this.nowTokenIs(Tokens.Identifier, Tokens.LeftCurlyBracket, Tokens.LeftSquareBracket, Tokens.Write)) {
      this.Statement();
    }

    if (this.nowTokenIs(Tokens.RightBracket)) {
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingRightBracket, this.nowToken);
    }

    this.buildCode("}");
    this.leaveBlock();
  }

  private ForHead(): void {
    const indexVar = this.nowToken!;
    this.buildCode(`for(let `);
    this.Identifier(false);
    if (this.nowTokenIs(Tokens.Assign)) {
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingAssignOperator, this.nowToken);
      skip(this, Tokens.ForHead);
    }
    this.buildCode("=");
    this.Expression();
    this.buildCode(`;${makeId(indexVar.value)}<=`);
    if (this.nowTokenIs(Tokens.Arrow)) {
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingArrow, this.nowToken);
      skip(this, Tokens.ForHead);
      return;
    }
    this.Expression();
    this.buildCode(`;++${makeId(indexVar.value)})`);
    if (this.nowTokenIs(Tokens.RightSquareBracket)) {
      this.movePointerToNext();
    } else {
      ThrowError(this, Errors.MissingRightSquareBracket, this.nowToken);
      skip(this, Tokens.ForHead);
    }
    this.declareVariable(indexVar);
  }

  private Print(): void {
    this.buildCode("_write(");
    if (this.nowTokenIs(Tokens.String))
      this.String();
    else
      this.Expression();

    this.buildCode(")");
  }

  private Expression(): void {
    if (this.nowTokenIs(Tokens.Plus, Tokens.Minus)) {
      this.buildCode(this.nowToken!.value);
      this.movePointerToNext();
    }
    this.Term();

    while (this.nowTokenIs(Tokens.Plus, Tokens.Minus)) {
      this.buildCode(this.nowToken!.value);
      this.movePointerToNext();
      this.Term();
    }
  }

  private Term(): void {
    this.Factor();
    while (this.nowTokenIs(Tokens.Multiply, Tokens.Divide)) {
      this.buildCode(this.nowToken!.value);
      this.movePointerToNext();
      this.Factor()
    }
  }

  private Factor(): void {
    if (this.nowTokenIs(Tokens.Identifier)) {
      this.movePointerToNext();
      if (this.nowTokenIs(Tokens.LeftBracket)) {
        this.revert();
        this.buildCode(this.nowToken!.value);
        this.movePointerToNext();
        this.buildCode('(');
        this.movePointerToNext();
        this.Function();
        return;
      }
      this.revert();
      this.Identifier();
      return;
    }
    if (this.nowTokenIs(Tokens.Number)) {
      this.Number();
      return;
    }
    if (this.nowTokenIs(Tokens.LeftBracket)) {
      this.buildCode('(');
      this.movePointerToNext();
      this.Expression();
      if (this.nowTokenIs(Tokens.RightBracket)) {
        this.buildCode(')');
        this.movePointerToNext();
        return;
      }
      this.revert();
      ThrowError(this, Errors.MissingRightBracket, this.nowToken);
      skip(this, Tokens.Factor);
      return;
    }

    this.revert();
    ThrowError(this, Errors.MissingLeftBracket, this.nowToken);
    skip(this, Tokens.Factor);

  }

  private Identifier(checkExist = true, idToken = this.nowToken): void {
    if (idToken?.token === Tokens.Identifier) {
      this.buildCode(makeId(idToken.value));
      this.movePointerToNext();
      if (!checkExist) return;
      if (this.nowTokenIs(Tokens.LeftBracket)) return;

      this.revert();
      let identifier: Identifier | undefined;
      let level = this.nowLevel;
      while (level > 0 && !identifier) {
        identifier = this.idStack.getId(idToken.value, level--);
      }

      if (!identifier) {
        ThrowError(this, Errors.IdentifierNotDefined, this.nowToken);
        return;
      }

      this.movePointerToNext();
      return;
    }
    ThrowError(this, Errors.MissingIdentifier, this.nowToken);
  }

  private Number(): void {
    if (this.nowTokenIs(Tokens.Number)) {
      this.buildCode(this.nowToken!.value);
      this.movePointerToNext();
      return;
    }
    ThrowError(this, Errors.MissingNumber, this.nowToken);
  }

  private String(): void {
    if (this.nowTokenIs(Tokens.String)) {
      this.buildCode(this.nowToken!.value);
      this.movePointerToNext();
      return;
    }
    ThrowError(this, Errors.MissingString, this.nowToken);
    skip(this, Tokens.Statement);
  }

}

function makeId(identifierName: string): string {
  return `__hzs_C_${identifierName}`;
}

export { Parser }
